{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Color, FileLoader, Loader, LinearSRGBColorSpace, SRGBColorSpace } from 'three';\nconst _taskCache = new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = '';\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      this.parse(buffer, onLoad, onError);\n    }, onProgress, onError);\n  }\n  parse(buffer, onLoad, onError) {\n    this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace).catch(onError);\n  }\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    let vertexColorSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearSRGBColorSpace;\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n      vertexColorSpace: vertexColorSpace\n    };\n    return this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    const taskKey = JSON.stringify(taskConfig);\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    }\n\n    //\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]);\n\n        // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry));\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n\n        // this.debug();\n      }\n    });\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const result = geometryData.attributes[i];\n      const name = result.name;\n      const array = result.array;\n      const itemSize = result.itemSize;\n      const attribute = new BufferAttribute(array, itemSize);\n      if (name === 'color') {\n        this._assignVertexColorSpace(attribute, result.vertexColorSpace);\n        attribute.normalized = array instanceof Float32Array === false;\n      }\n      geometry.setAttribute(name, attribute);\n    }\n    return geometry;\n  }\n  _assignVertexColorSpace(attribute, inputColorSpace) {\n    // While .drc files do not specify colorspace, the only 'official' tooling\n    // is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n    // file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n    // to decode geometry, and vertex colors are already Linear-sRGB in there.\n\n    if (inputColorSpace !== SRGBColorSpace) return;\n    const _color = new Color();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();\n      attribute.setXYZ(i, _color.r, _color.g, _color.b);\n    }\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n        worker.onmessage = function (e) {\n          const message = e.data;\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n              break;\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    if (this.workerSourceURL !== '') {\n      URL.revokeObjectURL(this.workerSourceURL);\n    }\n    return this;\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n      case 'decode':\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          try {\n            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, array, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(array);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n    const geometry = {\n      index: null,\n      attributes: []\n    };\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);\n      if (attributeName === 'color') {\n        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n      }\n      geometry.attributes.push(attributeResult);\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport { DRACOLoader };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Color","FileLoader","Loader","LinearSRGBColorSpace","SRGBColorSpace","_taskCache","WeakMap","DRACOLoader","constructor","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parse","decodeDracoFile","catch","callback","attributeIDs","attributeTypes","vertexColorSpace","arguments","length","undefined","taskConfig","useUniqueIDs","decodeGeometry","then","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","result","name","itemSize","attribute","_assignVertexColorSpace","normalized","Float32Array","setAttribute","inputColorSpace","_color","il","count","fromBufferAttribute","convertSRGBToLinear","setXYZ","r","g","b","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","debug","log","map","dispose","terminate","revokeObjectURL","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeArrayToMesh","POINT_CLOUD","PointCloud","DecodeArrayToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","attributeResult","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"sources":["/Users/tny/Documents/GitHub/3D-cottage/node_modules/three/examples/jsm/loaders/DRACOLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tLoader,\n\tLinearSRGBColorSpace,\n\tSRGBColorSpace\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tthis.parse( buffer, onLoad, onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( buffer, onLoad, onError ) {\n\n\t\tthis.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );\n\n\t}\n\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs,\n\t\t\tvertexColorSpace: vertexColorSpace,\n\t\t};\n\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst result = geometryData.attributes[ i ];\n\t\t\tconst name = result.name;\n\t\t\tconst array = result.array;\n\t\t\tconst itemSize = result.itemSize;\n\n\t\t\tconst attribute = new BufferAttribute( array, itemSize );\n\n\t\t\tif ( name === 'color' ) {\n\n\t\t\t\tthis._assignVertexColorSpace( attribute, result.vertexColorSpace );\n\n\t\t\t\tattribute.normalized = ( array instanceof Float32Array ) === false;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( name, attribute );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_assignVertexColorSpace( attribute, inputColorSpace ) {\n\n\t\t// While .drc files do not specify colorspace, the only 'official' tooling\n\t\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n\t\t// file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n\t\t// to decode geometry, and vertex colors are already Linear-sRGB in there.\n\n\t\tif ( inputColorSpace !== SRGBColorSpace ) return;\n\n\t\tconst _color = new Color();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();\n\t\t\tattribute.setXYZ( i, _color.r, _color.g, _color.b );\n\n\t\t}\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\tif ( this.workerSourceURL !== '' ) {\n\n\t\t\tURL.revokeObjectURL( this.workerSourceURL );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, array, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( array );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tconst attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );\n\n\t\t\tif ( attributeName === 'color' ) {\n\n\t\t\t\tattributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( attributeResult );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n"],"mappings":"AAAA,SACCA,eAAe,EACfC,cAAc,EACdC,KAAK,EACLC,UAAU,EACVC,MAAM,EACNC,oBAAoB,EACpBC,cAAc,QACR,OAAO;AAEd,MAAMC,UAAU,GAAG,IAAIC,OAAO,CAAC,CAAC;AAEhC,MAAMC,WAAW,SAASL,MAAM,CAAC;EAEhCM,WAAWA,CAAEC,OAAO,EAAG;IAEtB,KAAK,CAAEA,OAAQ,CAAC;IAEhB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,cAAc,GAAG,IAAI;IAE1B,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACC,eAAe,GAAG,EAAE;IAEzB,IAAI,CAACC,mBAAmB,GAAG;MAC1BC,QAAQ,EAAE,UAAU;MACpBC,MAAM,EAAE,QAAQ;MAChBC,KAAK,EAAE,OAAO;MACdC,EAAE,EAAE;IACL,CAAC;IACD,IAAI,CAACC,qBAAqB,GAAG;MAC5BJ,QAAQ,EAAE,cAAc;MACxBC,MAAM,EAAE,cAAc;MACtBC,KAAK,EAAE,cAAc;MACrBC,EAAE,EAAE;IACL,CAAC;EAEF;EAEAE,cAAcA,CAAEC,IAAI,EAAG;IAEtB,IAAI,CAACf,WAAW,GAAGe,IAAI;IAEvB,OAAO,IAAI;EAEZ;EAEAC,gBAAgBA,CAAEC,MAAM,EAAG;IAE1B,IAAI,CAAChB,aAAa,GAAGgB,MAAM;IAE3B,OAAO,IAAI;EAEZ;EAEAC,cAAcA,CAAEd,WAAW,EAAG;IAE7B,IAAI,CAACA,WAAW,GAAGA,WAAW;IAE9B,OAAO,IAAI;EAEZ;EAEAe,IAAIA,CAAEC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAG;IAExC,MAAMC,MAAM,GAAG,IAAIjC,UAAU,CAAE,IAAI,CAACQ,OAAQ,CAAC;IAE7CyB,MAAM,CAACC,OAAO,CAAE,IAAI,CAACV,IAAK,CAAC;IAC3BS,MAAM,CAACE,eAAe,CAAE,aAAc,CAAC;IACvCF,MAAM,CAACG,gBAAgB,CAAE,IAAI,CAACC,aAAc,CAAC;IAC7CJ,MAAM,CAACK,kBAAkB,CAAE,IAAI,CAACC,eAAgB,CAAC;IAEjDN,MAAM,CAACL,IAAI,CAAEC,GAAG,EAAIW,MAAM,IAAM;MAE/B,IAAI,CAACC,KAAK,CAAED,MAAM,EAAEV,MAAM,EAAEE,OAAQ,CAAC;IAEtC,CAAC,EAAED,UAAU,EAAEC,OAAQ,CAAC;EAEzB;EAEAS,KAAKA,CAAED,MAAM,EAAEV,MAAM,EAAEE,OAAO,EAAG;IAEhC,IAAI,CAACU,eAAe,CAAEF,MAAM,EAAEV,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE3B,cAAe,CAAC,CAACwC,KAAK,CAAEX,OAAQ,CAAC;EAEpF;EAEAU,eAAeA,CAAEF,MAAM,EAAEI,QAAQ,EAAEC,YAAY,EAAEC,cAAc,EAA4C;IAAA,IAA1CC,gBAAgB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG9C,oBAAoB;IAEvG,MAAMiD,UAAU,GAAG;MAClBN,YAAY,EAAEA,YAAY,IAAI,IAAI,CAAC5B,mBAAmB;MACtD6B,cAAc,EAAEA,cAAc,IAAI,IAAI,CAACxB,qBAAqB;MAC5D8B,YAAY,EAAE,CAAC,CAAEP,YAAY;MAC7BE,gBAAgB,EAAEA;IACnB,CAAC;IAED,OAAO,IAAI,CAACM,cAAc,CAAEb,MAAM,EAAEW,UAAW,CAAC,CAACG,IAAI,CAAEV,QAAS,CAAC;EAElE;EAEAS,cAAcA,CAAEb,MAAM,EAAEW,UAAU,EAAG;IAEpC,MAAMI,OAAO,GAAGC,IAAI,CAACC,SAAS,CAAEN,UAAW,CAAC;;IAE5C;IACA;IACA,IAAK/C,UAAU,CAACsD,GAAG,CAAElB,MAAO,CAAC,EAAG;MAE/B,MAAMmB,UAAU,GAAGvD,UAAU,CAACwD,GAAG,CAAEpB,MAAO,CAAC;MAE3C,IAAKmB,UAAU,CAACE,GAAG,KAAKN,OAAO,EAAG;QAEjC,OAAOI,UAAU,CAACG,OAAO;MAE1B,CAAC,MAAM,IAAKtB,MAAM,CAACuB,UAAU,KAAK,CAAC,EAAG;QAErC;QACA;QACA;QACA;QACA,MAAM,IAAIC,KAAK,CAEd,iEAAiE,GACjE,gDAED,CAAC;MAEF;IAED;;IAEA;;IAEA,IAAIC,MAAM;IACV,MAAMC,MAAM,GAAG,IAAI,CAACnD,gBAAgB,EAAG;IACvC,MAAMoD,QAAQ,GAAG3B,MAAM,CAACuB,UAAU;;IAElC;IACA;IACA,MAAMK,eAAe,GAAG,IAAI,CAACC,UAAU,CAAEH,MAAM,EAAEC,QAAS,CAAC,CACzDb,IAAI,CAAIgB,OAAO,IAAM;MAErBL,MAAM,GAAGK,OAAO;MAEhB,OAAO,IAAIC,OAAO,CAAE,CAAEC,OAAO,EAAEC,MAAM,KAAM;QAE1CR,MAAM,CAACS,UAAU,CAAER,MAAM,CAAE,GAAG;UAAEM,OAAO;UAAEC;QAAO,CAAC;QAEjDR,MAAM,CAACU,WAAW,CAAE;UAAEC,IAAI,EAAE,QAAQ;UAAEC,EAAE,EAAEX,MAAM;UAAEf,UAAU;UAAEX;QAAO,CAAC,EAAE,CAAEA,MAAM,CAAG,CAAC;;QAEpF;MAED,CAAE,CAAC;IAEJ,CAAE,CAAC,CACFc,IAAI,CAAIwB,OAAO,IAAM,IAAI,CAACC,eAAe,CAAED,OAAO,CAACE,QAAS,CAAE,CAAC;;IAEjE;IACA;IACAZ,eAAe,CACbzB,KAAK,CAAE,MAAM,IAAK,CAAC,CACnBW,IAAI,CAAE,MAAM;MAEZ,IAAKW,MAAM,IAAIC,MAAM,EAAG;QAEvB,IAAI,CAACe,YAAY,CAAEhB,MAAM,EAAEC,MAAO,CAAC;;QAEnC;MAED;IAED,CAAE,CAAC;;IAEJ;IACA9D,UAAU,CAAC8E,GAAG,CAAE1C,MAAM,EAAE;MAEvBqB,GAAG,EAAEN,OAAO;MACZO,OAAO,EAAEM;IAEV,CAAE,CAAC;IAEH,OAAOA,eAAe;EAEvB;EAEAW,eAAeA,CAAEI,YAAY,EAAG;IAE/B,MAAMH,QAAQ,GAAG,IAAIlF,cAAc,CAAC,CAAC;IAErC,IAAKqF,YAAY,CAACC,KAAK,EAAG;MAEzBJ,QAAQ,CAACK,QAAQ,CAAE,IAAIxF,eAAe,CAAEsF,YAAY,CAACC,KAAK,CAACE,KAAK,EAAE,CAAE,CAAE,CAAC;IAExE;IAEA,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,YAAY,CAACK,UAAU,CAACvC,MAAM,EAAEsC,CAAC,EAAG,EAAG;MAE3D,MAAME,MAAM,GAAGN,YAAY,CAACK,UAAU,CAAED,CAAC,CAAE;MAC3C,MAAMG,IAAI,GAAGD,MAAM,CAACC,IAAI;MACxB,MAAMJ,KAAK,GAAGG,MAAM,CAACH,KAAK;MAC1B,MAAMK,QAAQ,GAAGF,MAAM,CAACE,QAAQ;MAEhC,MAAMC,SAAS,GAAG,IAAI/F,eAAe,CAAEyF,KAAK,EAAEK,QAAS,CAAC;MAExD,IAAKD,IAAI,KAAK,OAAO,EAAG;QAEvB,IAAI,CAACG,uBAAuB,CAAED,SAAS,EAAEH,MAAM,CAAC1C,gBAAiB,CAAC;QAElE6C,SAAS,CAACE,UAAU,GAAKR,KAAK,YAAYS,YAAY,KAAO,KAAK;MAEnE;MAEAf,QAAQ,CAACgB,YAAY,CAAEN,IAAI,EAAEE,SAAU,CAAC;IAEzC;IAEA,OAAOZ,QAAQ;EAEhB;EAEAa,uBAAuBA,CAAED,SAAS,EAAEK,eAAe,EAAG;IAErD;IACA;IACA;IACA;;IAEA,IAAKA,eAAe,KAAK9F,cAAc,EAAG;IAE1C,MAAM+F,MAAM,GAAG,IAAInG,KAAK,CAAC,CAAC;IAE1B,KAAM,IAAIwF,CAAC,GAAG,CAAC,EAAEY,EAAE,GAAGP,SAAS,CAACQ,KAAK,EAAEb,CAAC,GAAGY,EAAE,EAAEZ,CAAC,EAAG,EAAG;MAErDW,MAAM,CAACG,mBAAmB,CAAET,SAAS,EAAEL,CAAE,CAAC,CAACe,mBAAmB,CAAC,CAAC;MAChEV,SAAS,CAACW,MAAM,CAAEhB,CAAC,EAAEW,MAAM,CAACM,CAAC,EAAEN,MAAM,CAACO,CAAC,EAAEP,MAAM,CAACQ,CAAE,CAAC;IAEpD;EAED;EAEAC,YAAYA,CAAE9E,GAAG,EAAE+E,YAAY,EAAG;IAEjC,MAAM3E,MAAM,GAAG,IAAIjC,UAAU,CAAE,IAAI,CAACQ,OAAQ,CAAC;IAC7CyB,MAAM,CAACC,OAAO,CAAE,IAAI,CAACzB,WAAY,CAAC;IAClCwB,MAAM,CAACE,eAAe,CAAEyE,YAAa,CAAC;IACtC3E,MAAM,CAACK,kBAAkB,CAAE,IAAI,CAACC,eAAgB,CAAC;IAEjD,OAAO,IAAIgC,OAAO,CAAE,CAAEC,OAAO,EAAEC,MAAM,KAAM;MAE1CxC,MAAM,CAACL,IAAI,CAAEC,GAAG,EAAE2C,OAAO,EAAEtB,SAAS,EAAEuB,MAAO,CAAC;IAE/C,CAAE,CAAC;EAEJ;EAEAoC,OAAOA,CAAA,EAAG;IAET,IAAI,CAACC,YAAY,CAAC,CAAC;IAEnB,OAAO,IAAI;EAEZ;EAEAA,YAAYA,CAAA,EAAG;IAEd,IAAK,IAAI,CAAClG,cAAc,EAAG,OAAO,IAAI,CAACA,cAAc;IAErD,MAAMmG,KAAK,GAAG,OAAOC,WAAW,KAAK,QAAQ,IAAI,IAAI,CAACtG,aAAa,CAACkE,IAAI,KAAK,IAAI;IACjF,MAAMqC,gBAAgB,GAAG,EAAE;IAE3B,IAAKF,KAAK,EAAG;MAEZE,gBAAgB,CAACC,IAAI,CAAE,IAAI,CAACP,YAAY,CAAE,kBAAkB,EAAE,MAAO,CAAE,CAAC;IAEzE,CAAC,MAAM;MAENM,gBAAgB,CAACC,IAAI,CAAE,IAAI,CAACP,YAAY,CAAE,uBAAuB,EAAE,MAAO,CAAE,CAAC;MAC7EM,gBAAgB,CAACC,IAAI,CAAE,IAAI,CAACP,YAAY,CAAE,oBAAoB,EAAE,aAAc,CAAE,CAAC;IAElF;IAEA,IAAI,CAAC/F,cAAc,GAAG2D,OAAO,CAAC4C,GAAG,CAAEF,gBAAiB,CAAC,CACnD3D,IAAI,CAAI8D,SAAS,IAAM;MAEvB,MAAMC,SAAS,GAAGD,SAAS,CAAE,CAAC,CAAE;MAEhC,IAAK,CAAEL,KAAK,EAAG;QAEd,IAAI,CAACrG,aAAa,CAAC4G,UAAU,GAAGF,SAAS,CAAE,CAAC,CAAE;MAE/C;MAEA,MAAMG,EAAE,GAAGC,WAAW,CAACC,QAAQ,CAAC,CAAC;MAEjC,MAAMC,IAAI,GAAG,CACZ,qBAAqB,EACrBL,SAAS,EACT,EAAE,EACF,cAAc,EACdE,EAAE,CAACI,SAAS,CAAEJ,EAAE,CAACK,OAAO,CAAE,GAAI,CAAC,GAAG,CAAC,EAAEL,EAAE,CAACM,WAAW,CAAE,GAAI,CAAE,CAAC,CAC5D,CAACC,IAAI,CAAE,IAAK,CAAC;MAEd,IAAI,CAAC9G,eAAe,GAAG+G,GAAG,CAACC,eAAe,CAAE,IAAIC,IAAI,CAAE,CAAEP,IAAI,CAAG,CAAE,CAAC;IAEnE,CAAE,CAAC;IAEJ,OAAO,IAAI,CAAC9G,cAAc;EAE3B;EAEAyD,UAAUA,CAAEH,MAAM,EAAEC,QAAQ,EAAG;IAE9B,OAAO,IAAI,CAAC2C,YAAY,CAAC,CAAC,CAACxD,IAAI,CAAE,MAAM;MAEtC,IAAK,IAAI,CAACxC,UAAU,CAACmC,MAAM,GAAG,IAAI,CAACpC,WAAW,EAAG;QAEhD,MAAMoD,MAAM,GAAG,IAAIiE,MAAM,CAAE,IAAI,CAAClH,eAAgB,CAAC;QAEjDiD,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC;QACtBT,MAAM,CAACkE,UAAU,GAAG,CAAC,CAAC;QACtBlE,MAAM,CAACmE,SAAS,GAAG,CAAC;QAEpBnE,MAAM,CAACU,WAAW,CAAE;UAAEC,IAAI,EAAE,MAAM;UAAElE,aAAa,EAAE,IAAI,CAACA;QAAc,CAAE,CAAC;QAEzEuD,MAAM,CAACoE,SAAS,GAAG,UAAWC,CAAC,EAAG;UAEjC,MAAMxD,OAAO,GAAGwD,CAAC,CAACC,IAAI;UAEtB,QAASzD,OAAO,CAACF,IAAI;YAEpB,KAAK,QAAQ;cACZX,MAAM,CAACS,UAAU,CAAEI,OAAO,CAACD,EAAE,CAAE,CAACL,OAAO,CAAEM,OAAQ,CAAC;cAClD;YAED,KAAK,OAAO;cACXb,MAAM,CAACS,UAAU,CAAEI,OAAO,CAACD,EAAE,CAAE,CAACJ,MAAM,CAAEK,OAAQ,CAAC;cACjD;YAED;cACC0D,OAAO,CAACC,KAAK,CAAE,0CAA0C,GAAG3D,OAAO,CAACF,IAAI,GAAG,GAAI,CAAC;UAElF;QAED,CAAC;QAED,IAAI,CAAC9D,UAAU,CAACoG,IAAI,CAAEjD,MAAO,CAAC;MAE/B,CAAC,MAAM;QAEN,IAAI,CAACnD,UAAU,CAAC4H,IAAI,CAAE,UAAWC,CAAC,EAAEjC,CAAC,EAAG;UAEvC,OAAOiC,CAAC,CAACP,SAAS,GAAG1B,CAAC,CAAC0B,SAAS,GAAG,CAAE,CAAC,GAAG,CAAC;QAE3C,CAAE,CAAC;MAEJ;MAEA,MAAMnE,MAAM,GAAG,IAAI,CAACnD,UAAU,CAAE,IAAI,CAACA,UAAU,CAACmC,MAAM,GAAG,CAAC,CAAE;MAC5DgB,MAAM,CAACkE,UAAU,CAAEjE,MAAM,CAAE,GAAGC,QAAQ;MACtCF,MAAM,CAACmE,SAAS,IAAIjE,QAAQ;MAC5B,OAAOF,MAAM;IAEd,CAAE,CAAC;EAEJ;EAEAgB,YAAYA,CAAEhB,MAAM,EAAEC,MAAM,EAAG;IAE9BD,MAAM,CAACmE,SAAS,IAAInE,MAAM,CAACkE,UAAU,CAAEjE,MAAM,CAAE;IAC/C,OAAOD,MAAM,CAACS,UAAU,CAAER,MAAM,CAAE;IAClC,OAAOD,MAAM,CAACkE,UAAU,CAAEjE,MAAM,CAAE;EAEnC;EAEA0E,KAAKA,CAAA,EAAG;IAEPJ,OAAO,CAACK,GAAG,CAAE,aAAa,EAAE,IAAI,CAAC/H,UAAU,CAACgI,GAAG,CAAI7E,MAAM,IAAMA,MAAM,CAACmE,SAAU,CAAE,CAAC;EAEpF;EAEAW,OAAOA,CAAA,EAAG;IAET,KAAM,IAAIxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACzE,UAAU,CAACmC,MAAM,EAAE,EAAGsC,CAAC,EAAG;MAEnD,IAAI,CAACzE,UAAU,CAAEyE,CAAC,CAAE,CAACyD,SAAS,CAAC,CAAC;IAEjC;IAEA,IAAI,CAAClI,UAAU,CAACmC,MAAM,GAAG,CAAC;IAE1B,IAAK,IAAI,CAACjC,eAAe,KAAK,EAAE,EAAG;MAElC+G,GAAG,CAACkB,eAAe,CAAE,IAAI,CAACjI,eAAgB,CAAC;IAE5C;IAEA,OAAO,IAAI;EAEZ;AAED;;AAEA;;AAEA,SAASwG,WAAWA,CAAA,EAAG;EAEtB,IAAI9G,aAAa;EACjB,IAAIE,cAAc;EAElByH,SAAS,GAAG,SAAAA,CAAWC,CAAC,EAAG;IAE1B,MAAMxD,OAAO,GAAGwD,CAAC,CAACC,IAAI;IAEtB,QAASzD,OAAO,CAACF,IAAI;MAEpB,KAAK,MAAM;QACVlE,aAAa,GAAGoE,OAAO,CAACpE,aAAa;QACrCE,cAAc,GAAG,IAAI2D,OAAO,CAAE,UAAWC,OAAO,eAAe;UAE9D9D,aAAa,CAACwI,cAAc,GAAG,UAAWC,KAAK,EAAG;YAEjD;YACA3E,OAAO,CAAE;cAAE2E,KAAK,EAAEA;YAAM,CAAE,CAAC;UAE5B,CAAC;UAEDC,kBAAkB,CAAE1I,aAAc,CAAC,CAAC,CAAC;QAEtC,CAAE,CAAC;QACH;MAED,KAAK,QAAQ;QACZ,MAAM8B,MAAM,GAAGsC,OAAO,CAACtC,MAAM;QAC7B,MAAMW,UAAU,GAAG2B,OAAO,CAAC3B,UAAU;QACrCvC,cAAc,CAAC0C,IAAI,CAAI+F,MAAM,IAAM;UAElC,MAAMF,KAAK,GAAGE,MAAM,CAACF,KAAK;UAC1B,MAAMG,OAAO,GAAG,IAAIH,KAAK,CAACI,OAAO,CAAC,CAAC;UAEnC,IAAI;YAEH,MAAMvE,QAAQ,GAAG3B,cAAc,CAAE8F,KAAK,EAAEG,OAAO,EAAE,IAAIE,SAAS,CAAEhH,MAAO,CAAC,EAAEW,UAAW,CAAC;YAEtF,MAAMsG,OAAO,GAAGzE,QAAQ,CAACQ,UAAU,CAACsD,GAAG,CAAIY,IAAI,IAAMA,IAAI,CAACpE,KAAK,CAAC9C,MAAO,CAAC;YAExE,IAAKwC,QAAQ,CAACI,KAAK,EAAGqE,OAAO,CAACvC,IAAI,CAAElC,QAAQ,CAACI,KAAK,CAACE,KAAK,CAAC9C,MAAO,CAAC;YAEjEmH,IAAI,CAAChF,WAAW,CAAE;cAAEC,IAAI,EAAE,QAAQ;cAAEC,EAAE,EAAEC,OAAO,CAACD,EAAE;cAAEG;YAAS,CAAC,EAAEyE,OAAQ,CAAC;UAE1E,CAAC,CAAC,OAAQhB,KAAK,EAAG;YAEjBD,OAAO,CAACC,KAAK,CAAEA,KAAM,CAAC;YAEtBkB,IAAI,CAAChF,WAAW,CAAE;cAAEC,IAAI,EAAE,OAAO;cAAEC,EAAE,EAAEC,OAAO,CAACD,EAAE;cAAE4D,KAAK,EAAEA,KAAK,CAAC3D;YAAQ,CAAE,CAAC;UAE5E,CAAC,SAAS;YAETqE,KAAK,CAACS,OAAO,CAAEN,OAAQ,CAAC;UAEzB;QAED,CAAE,CAAC;QACH;IAEF;EAED,CAAC;EAED,SAASjG,cAAcA,CAAE8F,KAAK,EAAEG,OAAO,EAAEhE,KAAK,EAAEnC,UAAU,EAAG;IAE5D,MAAMN,YAAY,GAAGM,UAAU,CAACN,YAAY;IAC5C,MAAMC,cAAc,GAAGK,UAAU,CAACL,cAAc;IAEhD,IAAI+G,aAAa;IACjB,IAAIC,cAAc;IAElB,MAAMC,YAAY,GAAGT,OAAO,CAACU,sBAAsB,CAAE1E,KAAM,CAAC;IAE5D,IAAKyE,YAAY,KAAKZ,KAAK,CAACc,eAAe,EAAG;MAE7CJ,aAAa,GAAG,IAAIV,KAAK,CAACe,IAAI,CAAC,CAAC;MAChCJ,cAAc,GAAGR,OAAO,CAACa,iBAAiB,CAAE7E,KAAK,EAAEA,KAAK,CAACvB,UAAU,EAAE8F,aAAc,CAAC;IAErF,CAAC,MAAM,IAAKE,YAAY,KAAKZ,KAAK,CAACiB,WAAW,EAAG;MAEhDP,aAAa,GAAG,IAAIV,KAAK,CAACkB,UAAU,CAAC,CAAC;MACtCP,cAAc,GAAGR,OAAO,CAACgB,uBAAuB,CAAEhF,KAAK,EAAEA,KAAK,CAACvB,UAAU,EAAE8F,aAAc,CAAC;IAE3F,CAAC,MAAM;MAEN,MAAM,IAAI7F,KAAK,CAAE,8CAA+C,CAAC;IAElE;IAEA,IAAK,CAAE8F,cAAc,CAACS,EAAE,CAAC,CAAC,IAAIV,aAAa,CAACW,GAAG,KAAK,CAAC,EAAG;MAEvD,MAAM,IAAIxG,KAAK,CAAE,sCAAsC,GAAG8F,cAAc,CAACW,SAAS,CAAC,CAAE,CAAC;IAEvF;IAEA,MAAMzF,QAAQ,GAAG;MAAEI,KAAK,EAAE,IAAI;MAAEI,UAAU,EAAE;IAAG,CAAC;;IAEhD;IACA,KAAM,MAAMkF,aAAa,IAAI7H,YAAY,EAAG;MAE3C,MAAM8H,aAAa,GAAGhB,IAAI,CAAE7G,cAAc,CAAE4H,aAAa,CAAE,CAAE;MAE7D,IAAI9E,SAAS;MACb,IAAIgF,WAAW;;MAEf;MACA;MACA;MACA;MACA,IAAKzH,UAAU,CAACC,YAAY,EAAG;QAE9BwH,WAAW,GAAG/H,YAAY,CAAE6H,aAAa,CAAE;QAC3C9E,SAAS,GAAG0D,OAAO,CAACuB,sBAAsB,CAAEhB,aAAa,EAAEe,WAAY,CAAC;MAEzE,CAAC,MAAM;QAENA,WAAW,GAAGtB,OAAO,CAACwB,cAAc,CAAEjB,aAAa,EAAEV,KAAK,CAAEtG,YAAY,CAAE6H,aAAa,CAAE,CAAG,CAAC;QAE7F,IAAKE,WAAW,KAAK,CAAE,CAAC,EAAG;QAE3BhF,SAAS,GAAG0D,OAAO,CAACyB,YAAY,CAAElB,aAAa,EAAEe,WAAY,CAAC;MAE/D;MAEA,MAAMI,eAAe,GAAGC,eAAe,CAAE9B,KAAK,EAAEG,OAAO,EAAEO,aAAa,EAAEa,aAAa,EAAEC,aAAa,EAAE/E,SAAU,CAAC;MAEjH,IAAK8E,aAAa,KAAK,OAAO,EAAG;QAEhCM,eAAe,CAACjI,gBAAgB,GAAGI,UAAU,CAACJ,gBAAgB;MAE/D;MAEAiC,QAAQ,CAACQ,UAAU,CAAC0B,IAAI,CAAE8D,eAAgB,CAAC;IAE5C;;IAEA;IACA,IAAKjB,YAAY,KAAKZ,KAAK,CAACc,eAAe,EAAG;MAE7CjF,QAAQ,CAACI,KAAK,GAAG8F,WAAW,CAAE/B,KAAK,EAAEG,OAAO,EAAEO,aAAc,CAAC;IAE9D;IAEAV,KAAK,CAACS,OAAO,CAAEC,aAAc,CAAC;IAE9B,OAAO7E,QAAQ;EAEhB;EAEA,SAASkG,WAAWA,CAAE/B,KAAK,EAAEG,OAAO,EAAEO,aAAa,EAAG;IAErD,MAAMsB,QAAQ,GAAGtB,aAAa,CAACuB,SAAS,CAAC,CAAC;IAC1C,MAAMC,UAAU,GAAGF,QAAQ,GAAG,CAAC;IAC/B,MAAMpH,UAAU,GAAGsH,UAAU,GAAG,CAAC;IAEjC,MAAMb,GAAG,GAAGrB,KAAK,CAACmC,OAAO,CAAEvH,UAAW,CAAC;IACvCuF,OAAO,CAACiC,uBAAuB,CAAE1B,aAAa,EAAE9F,UAAU,EAAEyG,GAAI,CAAC;IACjE,MAAMpF,KAAK,GAAG,IAAIoG,WAAW,CAAErC,KAAK,CAACsC,OAAO,CAACjJ,MAAM,EAAEgI,GAAG,EAAEa,UAAW,CAAC,CAACK,KAAK,CAAC,CAAC;IAC9EvC,KAAK,CAACwC,KAAK,CAAEnB,GAAI,CAAC;IAElB,OAAO;MAAElF,KAAK,EAAEF,KAAK;MAAEO,QAAQ,EAAE;IAAE,CAAC;EAErC;EAEA,SAASsF,eAAeA,CAAE9B,KAAK,EAAEG,OAAO,EAAEO,aAAa,EAAEa,aAAa,EAAEC,aAAa,EAAE/E,SAAS,EAAG;IAElG,MAAMgG,aAAa,GAAGhG,SAAS,CAACiG,cAAc,CAAC,CAAC;IAChD,MAAMC,SAAS,GAAGjC,aAAa,CAACkC,UAAU,CAAC,CAAC;IAC5C,MAAMC,SAAS,GAAGF,SAAS,GAAGF,aAAa;IAC3C,MAAM7H,UAAU,GAAGiI,SAAS,GAAGrB,aAAa,CAACsB,iBAAiB;IAC9D,MAAMC,QAAQ,GAAGC,gBAAgB,CAAEhD,KAAK,EAAEwB,aAAc,CAAC;IAEzD,MAAMH,GAAG,GAAGrB,KAAK,CAACmC,OAAO,CAAEvH,UAAW,CAAC;IACvCuF,OAAO,CAAC8C,iCAAiC,CAAEvC,aAAa,EAAEjE,SAAS,EAAEsG,QAAQ,EAAEnI,UAAU,EAAEyG,GAAI,CAAC;IAChG,MAAMlF,KAAK,GAAG,IAAIqF,aAAa,CAAExB,KAAK,CAACsC,OAAO,CAACjJ,MAAM,EAAEgI,GAAG,EAAEwB,SAAU,CAAC,CAACN,KAAK,CAAC,CAAC;IAC/EvC,KAAK,CAACwC,KAAK,CAAEnB,GAAI,CAAC;IAElB,OAAO;MACN9E,IAAI,EAAEgF,aAAa;MACnBpF,KAAK,EAAEA,KAAK;MACZK,QAAQ,EAAEiG;IACX,CAAC;EAEF;EAEA,SAASO,gBAAgBA,CAAEhD,KAAK,EAAEwB,aAAa,EAAG;IAEjD,QAASA,aAAa;MAErB,KAAK5E,YAAY;QAAE,OAAOoD,KAAK,CAACkD,UAAU;MAC1C,KAAK7C,SAAS;QAAE,OAAOL,KAAK,CAACmD,OAAO;MACpC,KAAKC,UAAU;QAAE,OAAOpD,KAAK,CAACqD,QAAQ;MACtC,KAAKC,UAAU;QAAE,OAAOtD,KAAK,CAACuD,QAAQ;MACtC,KAAKC,UAAU;QAAE,OAAOxD,KAAK,CAACyD,QAAQ;MACtC,KAAKC,WAAW;QAAE,OAAO1D,KAAK,CAAC2D,SAAS;MACxC,KAAKtB,WAAW;QAAE,OAAOrC,KAAK,CAAC4D,SAAS;IAEzC;EAED;AAED;AAEA,SAASzM,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}